<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithm Benchmarker</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            color: #1a1a1a;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 { color: #2c3e50; margin-bottom: 10px; }
        
        /* Stats Dashboard */
        .stats-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
            background: #ffffff;
            padding: 15px 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            border: 1px solid #dcdde1;
        }
        .stat-item { text-align: center; font-size: 0.9em; color: #7f8c8d; }
        .stat-value { display: block; font-weight: bold; color: #2980b9; font-size: 1.2em; font-family: monospace; }

        .controls {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            margin-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            align-items: center;
        }
        
        select, input, button {
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        button {
            background-color: #2ecc71;
            color: white;
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s;
        }
        button:hover { background-color: #27ae60; transform: translateY(-1px); }
        button:active { transform: translateY(0); }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }

        #visualizer {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 300px;
            width: 100%;
            max-width: 900px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 20px;
            overflow: hidden;
        }
        .bar { margin: 0 1px; background-color: #3498db; }
        .bar.sorted { background-color: #2ecc71; }
        .bar.reading { background-color: #e74c3c; }
        .bar.swapping { background-color: #f1c40f; }
    </style>
</head>
<body>
    <h1>Sorting Lab</h1>

    <div class="stats-container">
        <div class="stat-item">Comparisons<span id="stat-comp" class="stat-value">0</span></div>
        <div class="stat-item">Array Reads<span id="stat-reads" class="stat-value">0</span></div>
        <div class="stat-item">Array Writes<span id="stat-writes" class="stat-value">0</span></div>
        <div class="stat-item">Normalized Time<span id="stat-time" class="stat-value">0.00</span></div>
    </div>

    <div class="controls">
        <select id="algorithm">
            <optgroup label="Efficient - O(n log n)">
                <option value="quick">Quick Sort [O(n log n)]</option>
                <option value="merge">Merge Sort [O(n log n)]</option>
                <option value="heap">Heap Sort [O(n log n)]</option>
                <option value="shell">Shell Sort [O(n log n)]</option>
                <option value="comb">Comb Sort [O(n log n)]</option>
            </optgroup>
            <optgroup label="Simple - O(n²)">
                <option value="bubble">Bubble Sort [O(n²)]</option>
                <option value="insertion">Insertion Sort [O(n²)]</option>
                <option value="selection">Selection Sort [O(n²)]</option>
                <option value="cocktail">Cocktail Sort [O(n²)]</option>
                <option value="gnome">Gnome Sort [O(n²)]</option>
            </optgroup>
            <optgroup label="Experimental">
                <option value="bogo">Bogo Sort [O(n · n!)]</option>
            </optgroup>
        </select>
        
        <label>Size:</label>
        <input type="number" id="size" min="5" max="200" value="50">
        
        <label>Speed (ms):</label>
        <input type="number" id="delay" min="0" max="1000" value="10">
        
        <button id="startBtn" onclick="startSorting()">Execute</button>
        <button onclick="resetArray()">Reset</button>
    </div>

    <div id="visualizer"></div>

    <script>
        let array = [], sortedArray = [], bars = [];
        let delay = 10, isSorting = false, stopRequested = false;
        let reads = 0, writes = 0, comps = 0;
        let audioCtx = null;

        // --- Core Stats Engine ---

        function updateStats() {
            document.getElementById('stat-reads').innerText = reads;
            document.getElementById('stat-writes').innerText = writes;
            document.getElementById('stat-comp').innerText = comps;
            // Time complexity simulation: Reads + Writes + Comparisons
            const totalWork = reads + writes + comps;
            document.getElementById('stat-time').innerText = (totalWork * 0.01).toFixed(2) + " ms-units";
        }

        async function compare(val1, val2) {
            comps++;
            updateStats();
            return val1 > val2;
        }

        async function getVal(i) {
            reads++;
            updateStats();
            highlightBars([i], 'reading');
            playBeep(200 + array[i]);
            return array[i];
        }

        async function setVal(i, val) {
            writes++;
            array[i] = val;
            updateStats();
            updateBars();
            highlightBars([i], 'swapping');
            await sleep(delay);
            clearHighlights();
        }

        async function swap(i, j) {
            reads += 2; writes += 2;
            [array[i], array[j]] = [array[j], array[i]];
            updateStats();
            updateBars();
            highlightBars([i, j], 'swapping');
            playBeep(500);
            await sleep(delay);
            clearHighlights();
        }

        // --- Algorithms ---

        async function bubbleSort() {
            for (let i = 0; i < array.length; i++) {
                for (let j = 0; j < array.length - i - 1; j++) {
                    if (stopRequested) return;
                    if (await compare(await getVal(j), await getVal(j + 1))) {
                        await swap(j, j + 1);
                    }
                }
            }
        }

        async function gnomeSort() {
            let i = 0;
            while (i < array.length) {
                if (stopRequested) return;
                if (i === 0 || !(await compare(await getVal(i - 1), await getVal(i)))) {
                    i++;
                } else {
                    await swap(i, i - 1);
                    i--;
                }
            }
        }

        async function combSort() {
            let gap = array.length;
            let shrink = 1.3;
            let sorted = false;
            while (!sorted) {
                gap = Math.floor(gap / shrink);
                if (gap <= 1) { gap = 1; sorted = true; }
                for (let i = 0; i + gap < array.length; i++) {
                    if (await compare(await getVal(i), await getVal(i + gap))) {
                        await swap(i, i + gap);
                        sorted = false;
                    }
                }
            }
        }

        async function bogoSort() {
            if (array.length > 7) {
                alert("Bogo sort is O(n!) - please use size <= 7 to avoid freezing your browser!");
                return;
            }
            const isSorted = async () => {
                for (let i = 0; i < array.length - 1; i++) {
                    if (await compare(await getVal(i), await getVal(i+1))) return false;
                }
                return true;
            };
            while (!(await isSorted())) {
                if (stopRequested) return;
                // Shuffle
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    await swap(i, j);
                }
            }
        }

        // --- Standard Logic (Refactored) ---

        async function startSorting() {
            if (isSorting) return;
            isSorting = true;
            stopRequested = false;
            document.getElementById('startBtn').disabled = true;
            
            reads = 0; writes = 0; comps = 0;
            delay = parseInt(document.getElementById('delay').value);
            const algo = document.getElementById('algorithm').value;

            // Mapping
            if (algo === 'bubble') await bubbleSort();
            else if (algo === 'gnome') await gnomeSort();
            else if (algo === 'comb') await combSort();
            else if (algo === 'bogo') await bogoSort();
            else if (algo === 'quick') await quickSort(0, array.length - 1);
            else if (algo === 'selection') await selectionSort();
            else if (algo === 'insertion') await insertionSort();
            else if (algo === 'merge') await mergeSort(0, array.length - 1);
            else if (algo === 'heap') await heapSort();
            else if (algo === 'shell') await shellSort();
            else if (algo === 'cocktail') await cocktailSort();

            isSorting = false;
            document.getElementById('startBtn').disabled = false;
        }

        // --- Standard Sort Implementations (Integrated with Counters) ---

        async function quickSort(l, h) {
            if (l < h) {
                let p = await partition(l, h);
                await quickSort(l, p - 1);
                await quickSort(p + 1, h);
            }
        }

        async function partition(l, h) {
            let pivot = await getVal(h);
            let i = l - 1;
            for (let j = l; j < h; j++) {
                if (!(await compare(await getVal(j), pivot))) {
                    i++;
                    await swap(i, j);
                }
            }
            await swap(i + 1, h);
            return i + 1;
        }

        async function selectionSort() {
            for (let i = 0; i < array.length; i++) {
                let min = i;
                for (let j = i + 1; j < array.length; j++) {
                    if (await compare(await getVal(min), await getVal(j))) min = j;
                }
                if (min !== i) await swap(i, min);
            }
        }

        async function insertionSort() {
            for (let i = 1; i < array.length; i++) {
                let key = await getVal(i);
                let j = i - 1;
                while (j >= 0 && await compare(await getVal(j), key)) {
                    await setVal(j + 1, array[j]);
                    j--;
                }
                await setVal(j + 1, key);
            }
        }

        // --- Infrastructure ---

        function generateArray(size) {
            array = Array.from({length: size}, () => Math.floor(Math.random() * 280) + 20);
            sortedArray = [...array].sort((a,b) => a-b);
            const container = document.getElementById('visualizer');
            container.innerHTML = '';
            bars = array.map(v => {
                const b = document.createElement('div');
                b.className = 'bar';
                b.style.width = `${Math.max(2, (container.clientWidth / size) - 2)}px`;
                container.appendChild(b);
                return b;
            });
            updateBars();
            reads = 0; writes = 0; comps = 0; updateStats();
        }

        function updateBars() {
            const max = Math.max(...array);
            bars.forEach((b, i) => {
                b.style.height = `${(array[i]/max)*100}%`;
                b.classList.toggle('sorted', array[i] === sortedArray[i]);
            });
        }

        function highlightBars(indices, cls) {
            indices.forEach(i => bars[i] && bars[i].classList.add(cls));
        }

        function clearHighlights() {
            bars.forEach(b => b.classList.remove('reading', 'swapping'));
        }

        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        function playBeep(f) {
            if (!audioCtx) audioCtx = new AudioContext();
            let o = audioCtx.createOscillator(), g = audioCtx.createGain();
            o.connect(g); g.connect(audioCtx.destination);
            o.frequency.value = f; g.gain.setTargetAtTime(0, audioCtx.currentTime, 0.05);
            o.start(); o.stop(audioCtx.currentTime + 0.05);
        }

        function resetArray() {
            if (isSorting) { stopRequested = true; window.location.reload(); }
            generateArray(parseInt(document.getElementById('size').value));
        }

        window.onload = () => generateArray(50);
    </script>
</body>
</html>
