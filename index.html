<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Lab Pro - Benchmarker</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            color: #1a1a1a;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 { color: #2c3e50; margin-bottom: 10px; }
        
        .stats-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
            background: #ffffff;
            padding: 15px 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            border: 1px solid #dcdde1;
            width: 100%;
            max-width: 900px;
        }
        .stat-item { text-align: center; font-size: 0.85em; color: #7f8c8d; text-transform: uppercase; }
        .stat-value { display: block; font-weight: bold; color: #2980b9; font-size: 1.3em; font-family: 'Courier New', monospace; }

        .controls {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            align-items: center;
        }
        
        select, input, button { padding: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 14px; }
        button { background-color: #2ecc71; color: white; border: none; font-weight: bold; cursor: pointer; transition: 0.2s; }
        button:hover { background-color: #27ae60; }
        button#resetBtn { background-color: #e74c3c; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }

        .audio-control {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            cursor: pointer;
        }

        #visualizer {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 300px;
            width: 100%;
            max-width: 900px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 20px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        .bar { margin: 0 1px; background-color: #3498db; }
        .bar.sorted { background-color: #2ecc71; }
        .bar.reading { background-color: #e74c3c; }
        .bar.swapping { background-color: #f1c40f; }

        #description-panel {
            max-width: 900px;
            background: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            border-left: 5px solid #2980b9;
            line-height: 1.6;
        }
        #description-panel h3 { margin-top: 0; color: #2980b9; }
    </style>
</head>
<body>
    <h1>Sorting Lab Pro</h1>

    <div class="stats-container">
        <div class="stat-item">Comparisons<span id="stat-comp" class="stat-value">0</span></div>
        <div class="stat-item">Reads<span id="stat-reads" class="stat-value">0</span></div>
        <div class="stat-item">Writes<span id="stat-writes" class="stat-value">0</span></div>
        <div class="stat-item">Norm. Time<span id="stat-time" class="stat-value">0.00</span></div>
    </div>

    <div class="controls">
        <select id="algorithm" onchange="updateDescription()">
            <optgroup label="Modern & Hybrid">
                <option value="timsort">Timsort [O(n log n)]</option>
                <option value="quick">Quick Sort [O(n log n)]</option>
                <option value="merge">Merge Sort [O(n log n)]</option>
            </optgroup>
            <optgroup label="Non-Comparative">
                <option value="radix">Radix Sort (LSD) [O(nk)]</option>
            </optgroup>
            <optgroup label="Classic">
                <option value="heap">Heap Sort [O(n log n)]</option>
                <option value="shell">Shell Sort [O(n log n)]</option>
                <option value="bubble">Bubble Sort [O(nÂ²)]</option>
                <option value="insertion">Insertion Sort [O(nÂ²)]</option>
                <option value="selection">Selection Sort [O(nÂ²)]</option>
            </optgroup>
            <optgroup label="Experimental">
                <option value="bogo">Bogo Sort [O(n Â· n!)]</option>
            </optgroup>
        </select>
        
        <label>Size:</label>
        <input type="number" id="size" min="5" max="250" value="50">
        <label>Delay (ms):</label>
        <input type="number" id="delay" min="1" max="500" value="30">
        
        <label class="audio-control">
            <input type="checkbox" id="audioToggle" checked> ðŸ”Š Sound
        </label>

        <button id="startBtn" onclick="startSorting()">Run</button>
        <button id="resetBtn" onclick="resetArray()">Reset</button>
    </div>

    <div id="visualizer"></div>

    <div id="description-panel">
        <h3 id="desc-title">Select an algorithm</h3>
        <p id="desc-text">Pick a method from the menu to see how it works and its speed.</p>
    </div>

    <script>
        let array = [], sortedArray = [], bars = [];
        let delay = 30, isSorting = false, abortController = new AbortController();
        let reads = 0, writes = 0, comps = 0;
        let audioCtx = null;

        const descriptions = {
            timsort: {
                title: "Timsort",
                text: "The modern standard used in Python and Java. It is a smart mix of Merge Sort and Insertion Sort. It looks for parts of the data that are already sorted to speed things up. Very efficient for real-world information."
            },
            radix: {
                title: "Radix Sort (LSD)",
                text: "A unique method that doesn't compare numbers. Instead, it sorts items digit by digit (from right to left). It puts numbers into 10 'buckets' (0-9). You will notice the 'Comparisons' count stays at zero!"
            },
            quick: {
                title: "Quick Sort",
                text: "One of the fastest methods. It picks a 'pivot' value and moves smaller items to the left and larger items to the right. It is very fast because it works well with computer memory."
            },
            merge: {
                title: "Merge Sort",
                text: "A reliable 'divide and conquer' method. It splits the list into single items and then merges them back together in the correct order. It is very stable but needs a bit of extra space to work."
            },
            bubble: {
                title: "Bubble Sort",
                text: "A simple but slow method. It compares pairs of neighbors and swaps them if they are in the wrong order. Large values 'bubble up' to the end of the list one by one."
            },
            insertion: {
                title: "Insertion Sort",
                text: "Similar to how you sort playing cards in your hand. It takes one item at a time and slides it into the correct position among the items it has already checked."
            },
            selection: {
                title: "Selection Sort",
                text: "It scans the whole list to find the smallest number, then puts it at the beginning. It keeps doing this for the rest of the list. It does a lot of looking but very little moving."
            },
            heap: {
                title: "Heap Sort",
                text: "This method organizes the data into a tree-like structure called a 'Heap'. It repeatedly finds the largest item and moves it to the end. It's fast and doesn't need extra memory."
            },
            shell: {
                title: "Shell Sort",
                text: "An improved version of Insertion Sort. It starts by sorting pairs of items far apart from each other, then slowly reduces the distance between them."
            },
            bogo: {
                title: "Bogo Sort",
                text: "A joke algorithm. It shuffles the list randomly and checks if it's sorted. It is extremely slow and might take billions of years to sort a large list!"
            }
        };

        function updateDescription() {
            const val = document.getElementById('algorithm').value;
            document.getElementById('desc-title').innerText = descriptions[val].title;
            document.getElementById('desc-text').innerText = descriptions[val].text;
        }

        function updateStats() {
            document.getElementById('stat-reads').innerText = reads;
            document.getElementById('stat-writes').innerText = writes;
            document.getElementById('stat-comp').innerText = comps;
            document.getElementById('stat-time').innerText = ((reads + writes + comps) * 0.01).toFixed(2);
        }

        async function checkAbort() { if (abortController.signal.aborted) throw new Error("Abort"); }

        async function compare(v1, v2) {
            await checkAbort();
            comps++; updateStats();
            return v1 > v2;
        }

        async function getVal(i) {
            await checkAbort();
            reads++; updateStats();
            highlightBars([i], 'reading');
            playBeep(200 + array[i]);
            return array[i];
        }

        async function setVal(i, val) {
            await checkAbort();
            writes++; array[i] = val;
            updateStats(); updateBars();
            highlightBars([i], 'swapping');
            await sleep(delay);
            clearHighlights();
        }

        async function swap(i, j) {
            await checkAbort();
            reads += 2; writes += 2;
            [array[i], array[j]] = [array[j], array[i]];
            updateStats(); updateBars();
            highlightBars([i, j], 'swapping');
            playBeep(500);
            await sleep(delay);
            clearHighlights();
        }

        // --- ALGORITHMS ---

        async function timSort() {
            let n = array.length;
            const RUN = 32;
            for (let i = 0; i < n; i += RUN) {
                for (let j = i + 1; j < Math.min(i + RUN, n); j++) {
                    let temp = await getVal(j);
                    let k = j - 1;
                    while (k >= i && await compare(await getVal(k), temp)) {
                        await setVal(k + 1, array[k]);
                        k--;
                    }
                    await setVal(k + 1, temp);
                }
            }
            for (let size = RUN; size < n; size = 2 * size) {
                for (let left = 0; left < n; left += 2 * size) {
                    let mid = left + size - 1;
                    let right = Math.min(left + 2 * size - 1, n - 1);
                    if (mid < right) await merge(left, mid, right);
                }
            }
        }

        async function radixSort() {
            let max = Math.max(...array);
            for (let exp = 1; Math.floor(max / exp) > 0; exp *= 10) {
                await countSortForRadix(exp);
            }
        }

        async function countSortForRadix(exp) {
            let n = array.length;
            let output = new Array(n);
            let count = new Array(10).fill(0);
            for (let i = 0; i < n; i++) {
                let val = await getVal(i);
                count[Math.floor(val / exp) % 10]++;
            }
            for (let i = 1; i < 10; i++) count[i] += count[i - 1];
            for (let i = n - 1; i >= 0; i--) {
                let val = array[i];
                let digit = Math.floor(val / exp) % 10;
                output[count[digit] - 1] = val;
                count[digit]--;
                reads++;
            }
            for (let i = 0; i < n; i++) await setVal(i, output[i]);
        }

        async function merge(l, m, r) {
            let left = [], right = [];
            for (let i = l; i <= m; i++) left.push(await getVal(i));
            for (let i = m + 1; i <= r; i++) right.push(await getVal(i));
            let i = 0, j = 0, k = l;
            while (i < left.length && j < right.length) {
                if (left[i] <= right[j]) await setVal(k++, left[i++]);
                else await setVal(k++, right[j++]);
                comps++;
            }
            while (i < left.length) await setVal(k++, left[i++]);
            while (j < right.length) await setVal(k++, right[j++]);
        }

        async function quickSort(l, h) {
            if (l < h) {
                let pivot = await getVal(h), i = l - 1;
                for (let j = l; j < h; j++) {
                    if (!(await compare(await getVal(j), pivot))) { i++; await swap(i, j); }
                }
                await swap(i + 1, h);
                let p = i + 1;
                await quickSort(l, p - 1);
                await quickSort(p + 1, h);
            }
        }

        // --- UI & ENGINE ---

        async function startSorting() {
            if (isSorting) return;
            isSorting = true;
            document.getElementById('startBtn').disabled = true;
            abortController = new AbortController();
            reads = writes = comps = 0;
            delay = parseInt(document.getElementById('delay').value);
            const algo = document.getElementById('algorithm').value;

            try {
                if (algo === 'timsort') await timSort();
                else if (algo === 'radix') await radixSort();
                else if (algo === 'quick') await quickSort(0, array.length - 1);
                else if (algo === 'merge') {
                    const mSort = async (l, r) => {
                        if (l < r) {
                            let m = Math.floor((l+r)/2);
                            await mSort(l, m); await mSort(m+1, r);
                            await merge(l, m, r);
                        }
                    }
                    await mSort(0, array.length - 1);
                }
                else if (algo === 'bubble') {
                    for(let i=0; i<array.length; i++) 
                        for(let j=0; j<array.length-i-1; j++) 
                            if(await compare(await getVal(j), await getVal(j+1))) await swap(j, j+1);
                }
                else if (algo === 'insertion') {
                    for(let i=1; i<array.length; i++) {
                        let k = await getVal(i), j = i-1;
                        while(j>=0 && await compare(await getVal(j), k)) { await setVal(j+1, array[j]); j--; }
                        await setVal(j+1, k);
                    }
                }
                else if (algo === 'selection') {
                    for(let i=0; i<array.length; i++) {
                        let min = i;
                        for(let j=i+1; j<array.length; j++) 
                            if(await compare(await getVal(min), await getVal(j))) min = j;
                        await swap(i, min);
                    }
                }
                
                bars.forEach(b => b.classList.add('sorted'));
            } catch (e) { console.log("Process stopped"); } 
            finally {
                isSorting = false;
                document.getElementById('startBtn').disabled = false;
            }
        }

        function generateArray(size) {
            array = Array.from({length: size}, () => Math.floor(Math.random() * 280) + 20);
            sortedArray = [...array].sort((a,b) => a-b);
            const container = document.getElementById('visualizer');
            container.innerHTML = '';
            bars = array.map(() => {
                const b = document.createElement('div');
                b.className = 'bar';
                b.style.width = `${Math.max(1, (900 / size) - 2)}px`;
                container.appendChild(b);
                return b;
            });
            updateBars(); resetStats();
        }

        function updateBars() {
            const max = Math.max(...array);
            bars.forEach((b, i) => {
                b.style.height = `${(array[i]/max)*100}%`;
                b.classList.toggle('sorted', array[i] === sortedArray[i]);
            });
        }

        function resetStats() { reads = writes = comps = 0; updateStats(); }
        function highlightBars(ids, cls) { ids.forEach(i => bars[i] && bars[i].classList.add(cls)); }
        function clearHighlights() { bars.forEach(b => b.classList.remove('reading', 'swapping')); }
        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        function playBeep(f) {
            const audioEnabled = document.getElementById('audioToggle').checked;
            if (!audioEnabled) return;

            if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            let o = audioCtx.createOscillator(), g = audioCtx.createGain();
            o.connect(g); g.connect(audioCtx.destination);
            o.frequency.value = f; g.gain.setTargetAtTime(0, audioCtx.currentTime, 0.05);
            o.start(); o.stop(audioCtx.currentTime + 0.05);
        }

        function resetArray() {
            abortController.abort();
            setTimeout(() => { generateArray(parseInt(document.getElementById('size').value)); }, 100);
        }

        window.onload = () => { generateArray(50); updateDescription(); };
    </script>
</body>
</html>
