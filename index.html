<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Lab Pro - Educational Benchmarker</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            color: #1a1a1a;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 { color: #2c3e50; margin-bottom: 10px; }
        
        .stats-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
            background: #ffffff;
            padding: 15px 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            border: 1px solid #dcdde1;
            width: 100%;
            max-width: 900px;
        }
        .stat-item { text-align: center; font-size: 0.85em; color: #7f8c8d; text-transform: uppercase; }
        .stat-value { display: block; font-weight: bold; color: #2980b9; font-size: 1.3em; font-family: 'Courier New', monospace; }

        .controls {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            align-items: center;
        }
        
        select, input, button { padding: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 14px; }
        button { background-color: #2ecc71; color: white; border: none; font-weight: bold; cursor: pointer; transition: 0.2s; }
        button:hover { background-color: #27ae60; }
        button#resetBtn { background-color: #e74c3c; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }

        .audio-control { display: flex; align-items: center; gap: 5px; font-size: 14px; cursor: pointer; }

        #visualizer {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 300px;
            width: 100%;
            max-width: 900px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 20px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        .bar { margin: 0 1px; background-color: #3498db; }
        .bar.sorted { background-color: #2ecc71; }
        .bar.reading { background-color: #e74c3c; }
        .bar.swapping { background-color: #f1c40f; }

        #description-panel {
            max-width: 900px;
            background: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            border-left: 5px solid #2980b9;
            line-height: 1.6;
        }
        #description-panel h3 { margin-top: 0; color: #2980b9; }
        .complexity { font-weight: bold; color: #e67e22; margin-top: 10px; display: block; }
    </style>
</head>
<body>
    <h1>Sorting Lab Pro</h1>

    <div class="stats-container">
        <div class="stat-item">Comparisons<span id="stat-comp" class="stat-value">0</span></div>
        <div class="stat-item">Reads<span id="stat-reads" class="stat-value">0</span></div>
        <div class="stat-item">Writes<span id="stat-writes" class="stat-value">0</span></div>
        <div class="stat-item">Estimated Effort<span id="stat-time" class="stat-value">0.00</span></div>
    </div>

    <div class="controls">
        <select id="algorithm" onchange="updateDescription()">
            <optgroup label="Modern & Fast">
                <option value="timsort">Timsort (Java/Python Default)</option>
                <option value="quick">Quick Sort (Standard Fast)</option>
                <option value="merge">Merge Sort (Stable & Reliable)</option>
            </optgroup>
            <optgroup label="Unique Logic">
                <option value="radix">Radix Sort (No Comparisons!)</option>
                <option value="heap">Heap Sort (Memory Efficient)</option>
            </optgroup>
            <optgroup label="Simple Classics">
                <option value="shell">Shell Sort</option>
                <option value="insertion">Insertion Sort</option>
                <option value="selection">Selection Sort</option>
                <option value="bubble">Bubble Sort</option>
            </optgroup>
            <optgroup label="The Joke">
                <option value="bogo">Bogo Sort (Random Luck)</option>
            </optgroup>
        </select>
        
        <label>Size:</label>
        <input type="number" id="size" min="5" max="200" value="50">
        <label>Delay (ms):</label>
        <input type="number" id="delay" min="1" max="1000" value="30">
        
        <label class="audio-control">
            <input type="checkbox" id="audioToggle" checked> ðŸ”Š Sound
        </label>

        <button id="startBtn" onclick="startSorting()">Run Algorithm</button>
        <button id="resetBtn" onclick="resetArray()">Reset</button>
    </div>

    <div id="visualizer"></div>

    <div id="description-panel">
        <h3 id="desc-title">Select an algorithm</h3>
        <p id="desc-text">Pick a method from the menu to see how it works and its speed.</p>
        <span id="desc-comp" class="complexity"></span>
    </div>

    <script>
        let array = [], sortedArray = [], bars = [];
        let delay = 30, isSorting = false, abortController = new AbortController();
        let reads = 0, writes = 0, comps = 0;
        let audioCtx = null;

        const descriptions = {
            timsort: {
                title: "Timsort",
                text: "Timsort is a high-performance algorithm used by real-world systems like Android and Python. It works by finding small sections of data that are already sorted (called 'runs') and then merges those sections together using Merge Sort. It's incredibly smart and gets faster if the data is already partially in order.",
                comp: "Best Case: O(n) | Average: O(n log n)"
            },
            quick: {
                title: "Quick Sort",
                text: "Quick Sort uses a 'Divide and Conquer' strategy. It picks one number as a 'Pivot' and moves all smaller numbers to its left and all larger numbers to its right. It then repeats this for the left and right sides. It is usually the fastest method for general computer use.",
                comp: "Average Case: O(n log n)"
            },
            merge: {
                title: "Merge Sort",
                text: "Imagine splitting a deck of cards in half repeatedly until you have many tiny piles of 1 card each. Then, you merge them back together in pairs, making sure each new pile is sorted. This is Merge Sort. It is very reliable and never slows down, even with messy data.",
                comp: "Guaranteed Performance: O(n log n)"
            },
            radix: {
                title: "Radix Sort (LSD)",
                text: "Radix is a 'non-comparative' sort. It never asks 'is this number bigger than that one?'. Instead, it groups numbers by their digits (first the ones, then the tens, then the hundreds). Watch the stats: the 'Comparisons' counter will stay at zero!",
                comp: "Best for numbers: O(nk)"
            },
            heap: {
                title: "Heap Sort",
                text: "Heap Sort visualizes the list as a 'Binary Tree' (a family tree shape). It organizes the tree so the largest number is always at the top (the root). It then takes that largest number, puts it at the end of the list, and fixes the tree to find the next largest. It uses zero extra memory.",
                comp: "Average Case: O(n log n)"
            },
            bubble: {
                title: "Bubble Sort",
                text: "The most famous but least efficient way to sort. It compares every pair of neighbors. If they are in the wrong order, they swap. The largest numbers 'bubble up' to the end of the list like air bubbles in water. It's very slow for large lists.",
                comp: "Slowest Case: O(nÂ²)"
            },
            insertion: {
                title: "Insertion Sort",
                text: "This is exactly how most people sort a hand of playing cards. You take one item at a time and slide it into the correct spot among the items you've already sorted. It's very fast for very small lists.",
                comp: "Great for small data: O(nÂ²)"
            },
            selection: {
                title: "Selection Sort",
                text: "Selection Sort is very simple but repetitive. It scans the whole list to find the absolute smallest number and swaps it into the first position. Then it scans the rest to find the second smallest, and so on. It does very few 'Writes' but a lot of 'Comparisons'.",
                comp: "Constant Time: O(nÂ²)"
            },
            shell: {
                title: "Shell Sort",
                text: "Think of this as a 'long-distance' Insertion Sort. Instead of swapping neighbors, it swaps items that are far apart. It slowly reduces the gap between items until it finishes with a normal Insertion Sort. This 'pre-sorting' makes it much faster than the classics.",
                comp: "Average Case: O(n log n)"
            },
            bogo: {
                title: "Bogo Sort",
                text: "Also known as 'Stupid Sort'. It shuffles the list completely randomly and checks if it's sorted. If not, it shuffles again. It could finish in 1 second, or it could take 1,000 years. Don't use this for anything serious!",
                comp: "Complexity: O(Infinite Luck)"
            }
        };

        function updateDescription() {
            const val = document.getElementById('algorithm').value;
            document.getElementById('desc-title').innerText = descriptions[val].title;
            document.getElementById('desc-text').innerText = descriptions[val].text;
            document.getElementById('desc-comp').innerText = descriptions[val].comp;
        }

        // --- Core Helpers ---
        function updateStats() {
            document.getElementById('stat-reads').innerText = reads;
            document.getElementById('stat-writes').innerText = writes;
            document.getElementById('stat-comp').innerText = comps;
            document.getElementById('stat-time').innerText = ((reads + writes + comps) * 0.01).toFixed(2);
        }

        async function checkAbort() { if (abortController.signal.aborted) throw new Error("Abort"); }

        async function compare(v1, v2) {
            await checkAbort();
            comps++; updateStats();
            return v1 > v2;
        }

        async function getVal(i) {
            await checkAbort();
            reads++; updateStats();
            highlightBars([i], 'reading');
            playBeep(200 + array[i]);
            return array[i];
        }

        async function setVal(i, val) {
            await checkAbort();
            writes++; array[i] = val;
            updateStats(); updateBars();
            highlightBars([i], 'swapping');
            await sleep(delay);
            clearHighlights();
        }

        async function swap(i, j) {
            await checkAbort();
            reads += 2; writes += 2;
            [array[i], array[j]] = [array[j], array[i]];
            updateStats(); updateBars();
            highlightBars([i, j], 'swapping');
            playBeep(400);
            await sleep(delay);
            clearHighlights();
        }

        // --- ALGORITHMS ---

        async function bubbleSort() {
            let n = array.length;
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    if (await compare(await getVal(j), await getVal(j + 1))) await swap(j, j + 1);
                }
            }
        }

        async function selectionSort() {
            let n = array.length;
            for (let i = 0; i < n; i++) {
                let minIdx = i;
                for (let j = i + 1; j < n; j++) {
                    if (await compare(await getVal(minIdx), await getVal(j))) minIdx = j;
                }
                if (minIdx !== i) await swap(i, minIdx);
            }
        }

        async function insertionSort(start = 0, end = array.length - 1) {
            for (let i = start + 1; i <= end; i++) {
                let key = await getVal(i);
                let j = i - 1;
                while (j >= start && await compare(await getVal(j), key)) {
                    await setVal(j + 1, array[j]);
                    j--;
                }
                await setVal(j + 1, key);
            }
        }

        async function quickSort(low, high) {
            if (low < high) {
                let pivot = await getVal(high);
                let i = low - 1;
                for (let j = low; j < high; j++) {
                    if (!(await compare(await getVal(j), pivot))) {
                        i++;
                        await swap(i, j);
                    }
                }
                await swap(i + 1, high);
                let pi = i + 1;
                await quickSort(low, pi - 1);
                await quickSort(pi + 1, high);
            }
        }

        async function mergeSort(l, r) {
            if (l < r) {
                let m = Math.floor((l + r) / 2);
                await mergeSort(l, m);
                await mergeSort(m + 1, r);
                await merge(l, m, r);
            }
        }

        async function merge(l, m, r) {
            let n1 = m - l + 1, n2 = r - m;
            let L = [], R = [];
            for (let i = 0; i < n1; i++) L.push(await getVal(l + i));
            for (let j = 0; j < n2; j++) R.push(await getVal(m + 1 + j));
            let i = 0, j = 0, k = l;
            while (i < n1 && j < n2) {
                if (L[i] <= R[j]) await setVal(k++, L[i++]);
                else await setVal(k++, R[j++]);
            }
            while (i < n1) await setVal(k++, L[i++]);
            while (j < n2) await setVal(k++, R[j++]);
        }

        async function heapSort() {
            let n = array.length;
            const heapify = async (size, idx) => {
                let largest = idx, l = 2 * idx + 1, r = 2 * idx + 2;
                if (l < size && await compare(await getVal(l), await getVal(largest))) largest = l;
                if (r < size && await compare(await getVal(r), await getVal(largest))) largest = r;
                if (largest !== idx) {
                    await swap(idx, largest);
                    await heapify(size, largest);
                }
            };
            for (let i = Math.floor(n / 2) - 1; i >= 0; i--) await heapify(n, i);
            for (let i = n - 1; i > 0; i--) {
                await swap(0, i);
                await heapify(i, 0);
            }
        }

        async function radixSort() {
            let max = Math.max(...array);
            for (let exp = 1; Math.floor(max / exp) > 0; exp *= 10) {
                let output = new Array(array.length), count = new Array(10).fill(0);
                for (let i = 0; i < array.length; i++) {
                    let digit = Math.floor(await getVal(i) / exp) % 10;
                    count[digit]++;
                }
                for (let i = 1; i < 10; i++) count[i] += count[i - 1];
                for (let i = array.length - 1; i >= 0; i--) {
                    let val = array[i];
                    let digit = Math.floor(val / exp) % 10;
                    output[count[digit] - 1] = val;
                    count[digit]--;
                    reads++;
                }
                for (let i = 0; i < array.length; i++) await setVal(i, output[i]);
            }
        }

        async function timSort() {
            let n = array.length, RUN = 32;
            for (let i = 0; i < n; i += RUN) await insertionSort(i, Math.min(i + RUN - 1, n - 1));
            for (let size = RUN; size < n; size = 2 * size) {
                for (let left = 0; left < n; left += 2 * size) {
                    let mid = left + size - 1, right = Math.min(left + 2 * size - 1, n - 1);
                    if (mid < right) await merge(left, mid, right);
                }
            }
        }

        async function shellSort() {
            let n = array.length;
            for (let gap = Math.floor(n/2); gap > 0; gap = Math.floor(gap/2)) {
                for (let i = gap; i < n; i++) {
                    let temp = await getVal(i), j = i;
                    while (j >= gap && await compare(await getVal(j - gap), temp)) {
                        await setVal(j, array[j - gap]);
                        j -= gap;
                    }
                    await setVal(j, temp);
                }
            }
        }

        async function bogoSort() {
            const isSorted = () => {
                for (let i = 0; i < array.length - 1; i++) if (array[i] > array[i+1]) return false;
                return true;
            };
            while (!isSorted()) {
                await checkAbort();
                for (let i = array.length - 1; i > 0; i--) {
                    await swap(i, Math.floor(Math.random() * (i + 1)));
                }
            }
        }

        // --- Execution Logic ---
        async function startSorting() {
            if (isSorting) return;
            isSorting = true;
            document.getElementById('startBtn').disabled = true;
            abortController = new AbortController();
            reads = writes = comps = 0;
            delay = parseInt(document.getElementById('delay').value);
            const algo = document.getElementById('algorithm').value;

            try {
                if (algo === 'bubble') await bubbleSort();
                else if (algo === 'selection') await selectionSort();
                else if (algo === 'insertion') await insertionSort();
                else if (algo === 'quick') await quickSort(0, array.length - 1);
                else if (algo === 'merge') await mergeSort(0, array.length - 1);
                else if (algo === 'heap') await heapSort();
                else if (algo === 'radix') await radixSort();
                else if (algo === 'timsort') await timSort();
                else if (algo === 'shell') await shellSort();
                else if (algo === 'bogo') await bogoSort();
                
                bars.forEach(b => b.classList.add('sorted'));
            } catch (e) {
                console.log("Sort Aborted");
            } finally {
                isSorting = false;
                document.getElementById('startBtn').disabled = false;
            }
        }

        // --- Visuals & Audio ---
        function generateArray(size) {
            array = Array.from({length: size}, () => Math.floor(Math.random() * 280) + 20);
            sortedArray = [...array].sort((a,b) => a-b);
            const container = document.getElementById('visualizer');
            container.innerHTML = '';
            bars = array.map(() => {
                const b = document.createElement('div');
                b.className = 'bar';
                b.style.width = `${Math.max(1, (900 / size) - 2)}px`;
                container.appendChild(b);
                return b;
            });
            updateBars(); resetStats();
        }

        function updateBars() {
            const max = Math.max(...array);
            bars.forEach((b, i) => {
                b.style.height = `${(array[i]/max)*100}%`;
                b.classList.toggle('sorted', array[i] === sortedArray[i]);
            });
        }

        function resetStats() { reads = writes = comps = 0; updateStats(); }
        function highlightBars(ids, cls) { ids.forEach(i => bars[i] && bars[i].classList.add(cls)); }
        function clearHighlights() { bars.forEach(b => b.classList.remove('reading', 'swapping')); }
        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        function playBeep(f) {
            if (!document.getElementById('audioToggle').checked) return;
            if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            let o = audioCtx.createOscillator(), g = audioCtx.createGain();
            o.connect(g); g.connect(audioCtx.destination);
            o.frequency.value = f; g.gain.setTargetAtTime(0, audioCtx.currentTime, 0.05);
            o.start(); o.stop(audioCtx.currentTime + 0.05);
        }

        function resetArray() {
            abortController.abort();
            setTimeout(() => { generateArray(parseInt(document.getElementById('size').value)); }, 100);
        }

        window.onload = () => { generateArray(50); updateDescription(); };
    </script>
</body>
</html>
