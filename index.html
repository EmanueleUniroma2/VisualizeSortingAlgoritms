<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithm Benchmarker</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            color: #1a1a1a;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 { color: #2c3e50; margin-bottom: 10px; }
        
        .stats-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
            background: #ffffff;
            padding: 15px 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            border: 1px solid #dcdde1;
        }
        .stat-item { text-align: center; font-size: 0.9em; color: #7f8c8d; }
        .stat-value { display: block; font-weight: bold; color: #2980b9; font-size: 1.2em; font-family: monospace; }

        .controls {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            margin-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            align-items: center;
        }
        
        select, input, button { padding: 8px 12px; border: 1px solid #ccc; border-radius: 5px; font-size: 14px; }
        button { background-color: #2ecc71; color: white; border: none; font-weight: bold; cursor: pointer; }
        button:hover { background-color: #27ae60; }
        button#resetBtn { background-color: #e74c3c; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }

        #visualizer {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 300px;
            width: 100%;
            max-width: 900px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 20px;
            overflow: hidden;
        }
        .bar { margin: 0 1px; background-color: #3498db; }
        .bar.sorted { background-color: #2ecc71; }
        .bar.reading { background-color: #e74c3c; }
        .bar.swapping { background-color: #f1c40f; }
    </style>
</head>
<body>
    <h1>Visualize and compare different sorting algorithms</h1>

    <div class="stats-container">
        <div class="stat-item">Comparisons<span id="stat-comp" class="stat-value">0</span></div>
        <div class="stat-item">Reads<span id="stat-reads" class="stat-value">0</span></div>
        <div class="stat-item">Writes<span id="stat-writes" class="stat-value">0</span></div>
        <div class="stat-item">Normalized Time<span id="stat-time" class="stat-value">0.00</span></div>
    </div>

    <div class="controls">
        <select id="algorithm">
            <optgroup label="Efficient - O(n log n)">
                <option value="quick">Quick Sort [O(n log n)]</option>
                <option value="merge">Merge Sort [O(n log n)]</option>
                <option value="heap">Heap Sort [O(n log n)]</option>
                <option value="shell">Shell Sort [O(n log n)]</option>
                <option value="comb">Comb Sort [O(n log n)]</option>
            </optgroup>
            <optgroup label="Simple - O(n²)">
                <option value="bubble">Bubble Sort [O(n²)]</option>
                <option value="insertion">Insertion Sort [O(n²)]</option>
                <option value="selection">Selection Sort [O(n²)]</option>
                <option value="cocktail">Cocktail Sort [O(n²)]</option>
                <option value="gnome">Gnome Sort [O(n²)]</option>
            </optgroup>
            <optgroup label="Experimental">
                <option value="bogo">Bogo Sort [O(n · n!)]</option>
            </optgroup>
        </select>
        
        <label>Size:</label>
        <input type="number" id="size" min="5" max="200" value="40">
        <label>Delay (ms):</label>
        <input type="number" id="delay" min="10" max="100" value="30">
        
        <button id="startBtn" onclick="startSorting()">Execute</button>
        <button id="resetBtn" onclick="resetArray()">Reset</button>
    </div>

    <div id="visualizer"></div>

    <script>
        let array = [], sortedArray = [], bars = [];
        let delay = 10, isSorting = false, abortController = new AbortController();
        let reads = 0, writes = 0, comps = 0;
        let audioCtx = null;

        function updateStats() {
            document.getElementById('stat-reads').innerText = reads;
            document.getElementById('stat-writes').innerText = writes;
            document.getElementById('stat-comp').innerText = comps;
            const totalWork = reads + writes + comps;
            document.getElementById('stat-time').innerText = (totalWork * 0.01).toFixed(2);
        }

        async function checkAbort() {
            if (abortController.signal.aborted) throw new Error("Abort");
        }

        async function compare(val1, val2) {
            await checkAbort();
            comps++;
            updateStats();
            return val1 > val2;
        }

        async function getVal(i) {
            await checkAbort();
            reads++;
            updateStats();
            highlightBars([i], 'reading');
            playBeep(200 + array[i]);
            return array[i];
        }

        async function setVal(i, val) {
            await checkAbort();
            writes++;
            array[i] = val;
            updateStats();
            updateBars();
            highlightBars([i], 'swapping');
            await sleep(delay);
            clearHighlights();
        }

        async function swap(i, j) {
            await checkAbort();
            reads += 2; writes += 2;
            [array[i], array[j]] = [array[j], array[i]];
            updateStats();
            updateBars();
            highlightBars([i, j], 'swapping');
            playBeep(500);
            await sleep(delay);
            clearHighlights();
        }

        // --- ALGORITHMS ---

        async function bubbleSort() {
            let n = array.length;
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    if (await compare(await getVal(j), await getVal(j+1))) await swap(j, j+1);
                    clearHighlights();
                }
            }
        }

        async function insertionSort() {
            for (let i = 1; i < array.length; i++) {
                let key = await getVal(i);
                let j = i - 1;
                while (j >= 0 && await compare(await getVal(j), key)) {
                    await setVal(j + 1, array[j]);
                    j--;
                }
                await setVal(j + 1, key);
            }
        }

        async function selectionSort() {
            for (let i = 0; i < array.length; i++) {
                let min = i;
                for (let j = i + 1; j < array.length; j++) {
                    if (await compare(await getVal(min), await getVal(j))) min = j;
                    clearHighlights();
                }
                if (min !== i) await swap(i, min);
            }
        }

        async function quickSort(l, h) {
            if (l < h) {
                let pivot = await getVal(h);
                let i = l - 1;
                for (let j = l; j < h; j++) {
                    if (!(await compare(await getVal(j), pivot))) {
                        i++;
                        await swap(i, j);
                    }
                }
                await swap(i + 1, h);
                let p = i + 1;
                await quickSort(l, p - 1);
                await quickSort(p + 1, h);
            }
        }

        async function mergeSort(l, r) {
            if (l >= r) return;
            const m = Math.floor((l + r) / 2);
            await mergeSort(l, m);
            await mergeSort(m + 1, r);
            
            let left = [], right = [];
            for (let i = l; i <= m; i++) left.push(await getVal(i));
            for (let i = m + 1; i <= r; i++) right.push(await getVal(i));

            let i = 0, j = 0, k = l;
            while (i < left.length && j < right.length) {
                if (left[i] <= right[j]) await setVal(k++, left[i++]);
                else await setVal(k++, right[j++]);
                comps++; updateStats();
            }
            while (i < left.length) await setVal(k++, left[i++]);
            while (j < right.length) await setVal(k++, right[j++]);
        }

        async function heapify(n, i) {
            let largest = i, l = 2*i + 1, r = 2*i + 2;
            if (l < n && await compare(await getVal(l), await getVal(largest))) largest = l;
            if (r < n && await compare(await getVal(r), await getVal(largest))) largest = r;
            if (largest !== i) {
                await swap(i, largest);
                await heapify(n, largest);
            }
        }

        async function heapSort() {
            let n = array.length;
            for (let i = Math.floor(n/2)-1; i >= 0; i--) await heapify(n, i);
            for (let i = n-1; i > 0; i--) {
                await swap(0, i);
                await heapify(i, 0);
            }
        }

        async function shellSort() {
            let n = array.length;
            for (let gap = Math.floor(n/2); gap > 0; gap = Math.floor(gap/2)) {
                for (let i = gap; i < n; i++) {
                    let temp = await getVal(i);
                    let j;
                    for (j = i; j >= gap && await compare(await getVal(j - gap), temp); j -= gap) {
                        await setVal(j, array[j - gap]);
                    }
                    await setVal(j, temp);
                }
            }
        }

        async function combSort() {
            let gap = array.length, shrink = 1.3, sorted = false;
            while (!sorted) {
                gap = Math.floor(gap / shrink);
                if (gap <= 1) { gap = 1; sorted = true; }
                for (let i = 0; i + gap < array.length; i++) {
                    if (await compare(await getVal(i), await getVal(i + gap))) {
                        await swap(i, i + gap);
                        sorted = false;
                    }
                }
            }
        }

        async function cocktailSort() {
            let swapped = true, start = 0, end = array.length - 1;
            while (swapped) {
                swapped = false;
                for (let i = start; i < end; ++i) {
                    if (await compare(await getVal(i), await getVal(i + 1))) {
                        await swap(i, i + 1);
                        swapped = true;
                    }
                }
                if (!swapped) break;
                swapped = false; end--;
                for (let i = end - 1; i >= start; i--) {
                    if (await compare(await getVal(i), await getVal(i + 1))) {
                        await swap(i, i + 1);
                        swapped = true;
                    }
                }
                start++;
            }
        }

        async function gnomeSort() {
            let i = 0;
            while (i < array.length) {
                if (i === 0 || !(await compare(await getVal(i-1), await getVal(i)))) i++;
                else { await swap(i, i-1); i--; }
            }
        }

        async function bogoSort() {
            const isSorted = async () => {
                for (let i = 0; i < array.length - 1; i++) {
                    if (await compare(await getVal(i), await getVal(i+1))) return false;
                }
                return true;
            };
            while (!(await isSorted())) {
                for (let i = array.length - 1; i > 0; i--) {
                    await swap(i, Math.floor(Math.random() * (i + 1)));
                }
            }
        }

        // --- CORE FUNCTIONS ---

        async function startSorting() {
            if (isSorting) return;
            isSorting = true;
            document.getElementById('startBtn').disabled = true;
            abortController = new AbortController();
            
            reads = 0; writes = 0; comps = 0;
            delay = parseInt(document.getElementById('delay').value);
            const algo = document.getElementById('algorithm').value;

            try {
                if (algo === 'bubble') await bubbleSort();
                else if (algo === 'insertion') await insertionSort();
                else if (algo === 'selection') await selectionSort();
                else if (algo === 'quick') await quickSort(0, array.length - 1);
                else if (algo === 'merge') await mergeSort(0, array.length - 1);
                else if (algo === 'heap') await heapSort();
                else if (algo === 'shell') await shellSort();
                else if (algo === 'comb') await combSort();
                else if (algo === 'cocktail') await cocktailSort();
                else if (algo === 'gnome') await gnomeSort();
                else if (algo === 'bogo') await bogoSort();
                
                // Final visual completion
                bars.forEach(b => b.classList.add('sorted'));
                playBeep(880, 0.2);
            } catch (e) {
                console.log("Sort aborted or error:", e.message);
            } finally {
                isSorting = false;
                document.getElementById('startBtn').disabled = false;
                clearHighlights();
            }
        }

        function generateArray(size) {
            array = Array.from({length: size}, () => Math.floor(Math.random() * 280) + 20);
            sortedArray = [...array].sort((a,b) => a-b);
            const container = document.getElementById('visualizer');
            container.innerHTML = '';
            bars = array.map(v => {
                const b = document.createElement('div');
                b.className = 'bar';
                b.style.width = `${Math.max(1, (container.clientWidth / size) - 2)}px`;
                container.appendChild(b);
                return b;
            });
            updateBars();
            reads = 0; writes = 0; comps = 0; updateStats();
        }

        function updateBars() {
            const max = Math.max(...array);
            bars.forEach((b, i) => {
                b.style.height = `${(array[i]/max)*100}%`;
                b.classList.toggle('sorted', array[i] === sortedArray[i]);
            });
        }

        function highlightBars(indices, cls) {
            indices.forEach(i => bars[i] && bars[i].classList.add(cls));
        }

        function clearHighlights() {
            bars.forEach(b => b.classList.remove('reading', 'swapping'));
        }

        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        function playBeep(f) {
            if (!audioCtx) audioCtx = new AudioContext();
            let o = audioCtx.createOscillator(), g = audioCtx.createGain();
            o.connect(g); g.connect(audioCtx.destination);
            o.frequency.value = f; g.gain.setTargetAtTime(0, audioCtx.currentTime, 0.05);
            o.start(); o.stop(audioCtx.currentTime + 0.05);
        }

        function resetArray() {
            abortController.abort();
            setTimeout(() => {
                generateArray(parseInt(document.getElementById('size').value));
                isSorting = false;
                document.getElementById('startBtn').disabled = false;
            }, 50);
        }

        window.onload = () => generateArray(40);
    </script>
</body>
</html>
